/*
 * Copyright 2024-2025 NetCracker Technology Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.qubership.itool.utils;

import io.netty.buffer.ByteBufInputStream;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.core.json.jackson.DatabindCodec;
import io.vertx.core.json.pointer.JsonPointer;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import org.apache.commons.collections4.CollectionUtils;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import org.qubership.itool.modules.graph.FalloutDto;
import org.qubership.itool.modules.graph.GraphDataConstants;
import org.qubership.itool.modules.processor.GraphMetaInfoSupport;
import org.qubership.itool.modules.processor.MergerApi;

public class JsonUtils {

    public static final Charset UTF_8 = Charset.forName("UTF-8");

    private static final ObjectMapper mapper;
    private static final ObjectMapper prettyMapper;

    static {
        mapper = DatabindCodec.mapper().copy();
        prettyMapper = DatabindCodec.prettyMapper().copy();

        SimpleModule module = new SimpleModule();
        module.addDeserializer(JsonObject.class, new JsonObjectDeserializer());
        module.addDeserializer(JsonArray.class, new JsonArrayDeserializer());
        mapper.registerModule(module);
        prettyMapper.registerModule(module);
    }

    public static ObjectMapper mapper() {
        return mapper;
    }

    public static ObjectMapper prettyMapper() {
        return prettyMapper;
    }


    //------------------------------------------------------
    // IO and parsing

    /**
     * Extract fallout report from graph dump. Report is cumulative, that is,
     * includes description of errors of all the source graphs, transitively.
     * Objects are copied shallowly.
     *
     * @param dump Dump generated by {@link MergerApi} implementation.
     * @return Fallout report
     */
    public static List<FalloutDto> getFalloutReportFromDump(JsonObject dump) {
        return GraphMetaInfoSupport.getFalloutReportFromDump(dump);
    }

    /**
     * Read and parse a JSON file that contains an object (not array). Accepts GZIP as well.
     * To read array JSON or arbitrary data, use {@link #readJsonFile(String, Class)}
     *
     * @param path Path
     * @return File data
     * @throws IOException Exception
     */
    public static JsonObject readJsonFile(String path) throws IOException {
        return readJsonResource(JsonUtils.class, "file:" + path);
    }

    public static <T> T readJsonFile(String path, Class<T> dataType) throws IOException {
        return readJsonResource(JsonUtils.class, "file:" + path, dataType);
    }

    public static JsonObject readJsonResource(Class<?> caller, String location) throws IOException {
        return readJsonResource(caller, location, JsonObject.class);
    }

    public static <T> T readJsonResource(Class<?> caller, String location, Class<T> dataType) throws IOException {
        try (InputStream fis = FSUtils.openUrlStream(caller, location)) {
            if (fis == null) {  // This happens if source was not found
                return null;
            }
            Reader reader = new InputStreamReader(fis, UTF_8);
            return mapper.readValue(reader, dataType);
        }
    }

    public static JsonObject bytesToJsonObject(byte[] bytes) throws IOException {
        InputStream is = new ByteArrayInputStream(bytes);
        Reader reader = new InputStreamReader(is, UTF_8);
        return mapper.readValue(reader, JsonObject.class);
    }

    public static JsonObject gzipBytesToJsonObject(byte[] bytes) throws IOException {
        InputStream is = new GZIPInputStream(new ByteArrayInputStream(bytes));
        Reader reader = new InputStreamReader(is, UTF_8);
        return mapper.readValue(reader, JsonObject.class);
    }

    public static byte[] jsonObjectToGzipBytes(JsonObject dump) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        saveJsonToStream(new GZIPOutputStream(baos), dump, false);
        return baos.toByteArray();
    }

    public static JsonObject bufferToJsonObject(Buffer buffer) throws IOException {
        return readJsonFromBuffer(buffer, JsonObject.class);
    }

    public static JsonObject gzipBufferToJsonObject(Buffer buffer) throws IOException {
        return readJsonFromGzipBuffer(buffer, JsonObject.class);
    }

    public static <T> T readJsonFromBuffer(Buffer buffer, Class<T> clazz) throws IOException {
        InputStream is = new ByteBufInputStream(buffer.getByteBuf());
        Reader reader = new InputStreamReader(is, UTF_8);
        return mapper.readValue(reader, clazz);
    }

    public static <T> T readJsonFromGzipBuffer(Buffer buffer, Class<T> clazz) throws IOException {
        InputStream is = new GZIPInputStream(new ByteBufInputStream(buffer.getByteBuf()));
        Reader reader = new InputStreamReader(is, UTF_8);
        return mapper.readValue(reader, clazz);
    }

    public static void saveJsonToStream(OutputStream out, Object data, boolean pretty) throws IOException {
        ObjectMapper m = pretty ? prettyMapper : mapper;
        try (OutputStreamWriter writer = new OutputStreamWriter(out, UTF_8)) {
            m.writeValue(writer, data);
        }
    }

    public static void saveJson(Path path, Object data, boolean pretty) throws IOException {
        ObjectMapper m = pretty ? prettyMapper : mapper;
        try (OutputStream os = FSUtils.createFileOutputStream(path)) {
            m.writeValue(new OutputStreamWriter(os, UTF_8), data);
        }
    }


    //------------------------------------------------------
    // JSON structure manipulations

    public static JsonObject getOrCreateJsonObject(JsonObject startFrom, JsonPointer pointer) {
        JsonObject object = (JsonObject) pointer.queryJson(startFrom);
        if (object == null) {
            object = new JsonObject();
            pointer.writeJson(startFrom, object, true);
        }
        return object;
    }

    public static JsonObject getOrCreateJsonObject(JsonObject parent, String attrName) {
        JsonObject object = parent.getJsonObject(attrName);
        if (object == null) {
            object = new JsonObject();
            parent.put(attrName, object);
        }
        return object;
    }

    public static JsonArray getOrCreateJsonArray(JsonObject startFrom, JsonPointer pointer) {
        JsonArray array = (JsonArray) pointer.queryJson(startFrom);
        if (array == null) {
            array = new JsonArray();
            pointer.writeJson(startFrom, array, true);
        }
        return array;
    }

    public static JsonArray getOrCreateJsonArray(JsonObject parent, String attrName) {
        JsonArray array = parent.getJsonArray(attrName);
        if (array == null) {
            array = new JsonArray();
            parent.put(attrName, array);
        }
        return array;
    }

    public static void copyValueIfNotNull(JsonObject source, JsonObject target, String key) {
        Object value = source.getValue(key);
        if (value != null) {
            target.put(key, value);
        }
    }

    public static void copyValueIfAbsent(JsonObject source, JsonObject target, String key) {
        if (source == null) {
            return;
        }
        Object value = source.getValue(key);
        if (value != null && !target.containsKey(key)) {
            target.put(key, value);
        }
    }

    public static void putValueIfNotNull(JsonObject obj, String key, Object value) {
        if (value != null) {
            obj.put(key, value);
        }
    }


    //------------------------------------------------------
    // Converters

    @SuppressWarnings({"unchecked", "rawtypes"})
    public static JsonObject yamlToJson(String yaml, String sourceId) throws IOException {
        List<Object> sections = new YamlParser().parseYamlData(yaml, sourceId);
        if (CollectionUtils.isEmpty(sections)) {
            return null;
        }
        return new JsonObject((Map) sections.get(0));
    }

    /**
     * Converts:
     * <ul><li>null -&gt; null
     * <li>List or JsonArray -&gt; comma-separated String representation of list
     * <li>Other values -&gt; String representation
     * </ul>
     *
     * @param value Value
     * @return String representation
     */
    @SuppressWarnings("unchecked")
    public static String convertListToString(Object value) {
        if (value == null || value instanceof String) {
            return (String) value;
        }
        if (value instanceof JsonArray) {
            value = ((JsonArray)value).getList();
        }
        if (value instanceof List) {
            return ((List<Object>)value).stream()
                .map(String::valueOf)
                .collect(Collectors.joining(", "));
        }
        return value.toString();
    }

    @SuppressWarnings("unchecked")
    public static String convertListToFilteredString(Object value) {
        if (value == null || value instanceof String) {
            return (String) value;  // Do not filter it for now
        }
        if (value instanceof JsonArray) {
            value = ((JsonArray)value).getList();
        }
        if (value instanceof List) {
            return ((List<Object>)value).stream()
                .map(String::valueOf)
                .filter(s -> ! GraphDataConstants.NOS_TO_RECOGNIZE.contains(s))
                .collect(Collectors.joining(", "));
        }
        return value.toString();
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    public static JsonObject asJsonObject(Object value) {
        if (value == null) {
            return null;
        } else if (value instanceof JsonObject) {
            return (JsonObject) value;
        } else if (value instanceof Map) {
            return new JsonObject( (Map)value );
        } else {
            throw new ClassCastException("Cannot represent " + value.getClass().getName() + " as " + JsonObject.class.getName());
        }
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    public static <K, V> Map<K, V> asMap(Object value) {
        if (value == null) {
            return null;
        } else if (value instanceof Map) {
            return (Map) value;
        } else if (value instanceof JsonObject) {
            return (Map) ((JsonObject)value).getMap();
        } else {
            throw new ClassCastException("Cannot represent " + value.getClass().getName() + " as " + Map.class.getName());
        }
    }

    @SuppressWarnings({ "unchecked" })
    public static <K> List <K> asList(Object value) {
        if (value == null) {
            return null;
        } else if (value instanceof List) {
            return  (List<K>) value;
        } else if (value instanceof JsonArray) {
            return ((JsonArray) value).getList();
        } else {
            throw new ClassCastException("Cannot represent " + value.getClass().getName() + " as " + List.class.getName());
        }
    }
}
